function [ xdisp_filt,ydisp_filt ] = filterDisplacement( xdisp,ydisp,filterstruct,plotflag,obj_handle )
% Function for performing revised filtering of the displacement field in 
% FourDSTEM_Analysis_Engine.m. Takes a struct generated by
% buildFilterStruct.m as input.
%
% Nathanael Kazmierczak, 05/19/2020

if nargin < 4
    plotflag = false;
end
if nargin < 5
    obj_handle = [];
end

nfilters = numel(filterstruct);
xdisp_temp = xdisp;
ydisp_temp = ydisp;

for i = 1:nfilters
    filter = filterstruct(i);
    switch filter.target
        case 'xdisp'
            filtermat = xdisp_temp;
        case 'ydisp'
            filtermat = ydisp_temp;
        case 'amplitude'
            filtermat = (xdisp_temp.^2 + ydisp_temp.^2).^0.5;
        case 'angle'
            % Filtering on the angle per se doesn't do any good. This is
            % going to filter on the basis of AB/SP1,2,3 character. Will
            % take a little bit more work to program it out.
    end
    
    if plotflag > 0
        figure;
        imagesc(filtermat); colormap(parula); colorbar; axis equal; set(gca,'yDir','normal');
        xlabel('x');
        ylabel('y');
        title(sprintf('%s matrix before %s filtering',filter.target,filter.name));
        if plotflag > 1
            obj_handle.makeOutsideCustomDisplacementColorPlot(xdisp_temp,ydisp_temp);
            title(sprintf('%s matrix before %s filtering',filter.target,filter.name));
        end
    end
    
    switch filter.name
        case 'median normal'
            % The normal median filter parameter is simply the neighborhood
            % range. This is a built-in Matlab function.
            filtered_mat = medfilt2(filtermat,[filter.params,filter.params]);
        case 'median normal circle'
            filtered_mat = medfilt2_circle(filtermat,filter.params);  % which is the *diameter* of the circle, for consistency with square syntax
        case 'median outlier'
            % Median outlier filter only replaces values that deviate from
            % the median by more than tol = filter.params(2). The first
            % value still gives the filter range.
            filtered_mat = filterMedianOutlier(filtermat,filter.params(1),filter.params(2));
        case 'moving average'
            H = ones(filter.params);
            summed = filter2(H,filtermat);
            num = filter2(H,ones(size(filtermat)));
            filtered_mat = summed./num;
        case 'moving average circle'
            filtered_mat = movmeanfilt2_circle( filtermat, filter.params );
        case 'gaussian average'
            sigma = filter.params;
            filtered_mat = imgaussfilt(filtermat,sigma);
        case 'soft multistart'
%             filtered_mat = filterMedianNormal(filtermat);
            assert(strcmp(filter.target,'amplitude'));
            hard_flag = false;
            threshold = filter.params(1);
            range = filter.params(2);
            filtered_displacement = obj_handle.displacementContinuityFilter(threshold,range,hard_flag,xdisp_temp,ydisp_temp);
            xdisp_temp = filtered_displacement(:,:,1);
            ydisp_temp = filtered_displacement(:,:,2);
            filtered_mat = sqrt(xdisp_temp.^2 + ydisp_temp.^2);  % No need to perform further operations, since the multistart filter has to take care of this operation itself.
        case 'hard multistart'
            assert(strcmp(filter.target,'amplitude'));
            hard_flag = true;
            threshold = filter.params(1);
            range = filter.params(2);
            filtered_displacement = obj_handle.displacementContinuityFilter(threshold,range,hard_flag,xdisp_temp,ydisp_temp);
            xdisp_temp = filtered_displacement(:,:,1);
            ydisp_temp = filtered_displacement(:,:,2);
            filtered_mat = sqrt(xdisp_temp.^2 + ydisp_temp.^2);  
            % No need to perform further operations, since the multistart filter has to take care of this operation itself.
            disps = horzcat(xdisp_temp(:),ydisp_temp(:));
            [ reduced_zone_disps ] = extendedZoneDisp2ReducedZoneDisp( disps );
            xdisp_temp = reshape(reduced_zone_disps(:,1),size(xdisp_temp));
            ydisp_temp = reshape(reduced_zone_disps(:,2),size(ydisp_temp));
        case 'total variation'
            filtered_mat = TVM_image_denoise( filtermat, filter.params, false, '', parula );
    end
    
    if plotflag > 0
        figure;
        imagesc(filtered_mat); colormap(parula); colorbar; axis equal; set(gca,'yDir','normal');
        xlabel('x');
        ylabel('y');
        title(sprintf('%s matrix after %s filtering',filter.target,filter.name));
    end
    
    % Need to reform xdisp_temp and ydisp_temp, in case they were not
    % already. But not with the multistart, since those filters have
    % already done the special reforming.
    if ~(strcmp(filter.name,'soft multistart') || strcmp(filter.name,'hard multistart'))
        switch filter.target
            case 'xdisp'
                xdisp_temp = filtered_mat;
            case 'ydisp'
                ydisp_temp = filtered_mat;
            case 'amplitude'  % Figure out the scaling factor needed.
                % Note that this could possibly remove reduced zone
                % displacement vectors from the half hexagon, but unlikely
                % because of the geometry. Can also include the reduced zone
                % conversion function at the end if needed.
                old_amp = filtermat;
                new_amp = filtered_mat;
                scaling = new_amp./old_amp;
                xdisp_temp = xdisp_temp.*scaling;
                ydisp_temp = ydisp_temp.*scaling;
                
                logicals = (old_amp == 0);  % This will cause a divide by zero
                perturbs = [0,1;1,0;0,-1;-1,0];
                logical_idxs = find(logicals);
                for k = 1:numel(logical_idxs)
                    linidx = logical_idxs(k);
                    [ridx,cidx] = ind2sub(size(xdisp),linidx);
                    for q = 1:size(perturbs,1)
                        new_ridx = ridx + perturbs(q,1);
                        new_cidx = cidx + perturbs(q,2);
                        try 
                            adjacent_x = xdisp_temp(new_ridx,new_cidx);
                            adjacent_y = ydisp_temp(new_ridx,new_cidx);
                            break
                        catch 
                            % Go around to the next q
                        end   
                    end
                    xdisp_temp(ridx,cidx) = adjacent_x;
                    ydisp_temp(ridx,cidx) = adjacent_y;
                end
            case 'angle'
                % Filtering on the angle per se doesn't do any good. This is
                % going to filter on the basis of AB/SP1,2,3 character. Will
                % take a little bit more work to program it out.
        end
    end
    
    if plotflag > 1  % only by this point has the reforming of xdisp, ydisp surely happened.
        disps = horzcat(xdisp_temp(:),ydisp_temp(:));
        [ reduced_zone_disps ] = extendedZoneDisp2ReducedZoneDisp( disps );
        xdisp_plot = reshape(reduced_zone_disps(:,1),size(xdisp_temp));
        ydisp_plot = reshape(reduced_zone_disps(:,2),size(ydisp_temp));
        obj_handle.makeOutsideCustomDisplacementColorPlot(xdisp_plot,ydisp_plot);
        title(sprintf('%s matrix after %s filtering',filter.target,filter.name));
    end
end

xdisp_filt = xdisp_temp;
ydisp_filt = ydisp_temp;


if plotflag > 2
    figure
    scatter(xdisp_plot(:),ydisp_plot(:),3,'Filled');
    axh = gca;
    try
        plotFullDisplacementHexagons(axh);
    catch
        warning('Failed to plot full displacement hexagons in obj.makeDisplacementMapsFromBlinking()');
    end
    xlim([-1.5,1.5]);
    ylim([-0.1,1.5]);
    xlabel('Cartesian displacement component 1');
    ylabel('Cartesian displacement component 2');
    title('Displacement vector scatterplot');
    
    amplitude = sqrt(xdisp_plot.^2 + ydisp_plot.^2);
    figure
    histogram(amplitude(:));
    xlabel('Displacement amplitude (Angstrom)');
    ylabel('Counts');
    set(gca,'FontSize',14);
    
%     amplitude_trimmed = trimArray(amplitude,40);
    nAA = nnz(amplitude < 0.71);
    fprintf('Number of AA pixels in trimmed region is %d.\n',nAA);
end

end

